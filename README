Compliation
  You can compile the code with:
  $ make && make test
  
  If you would like to try out the example code, you can compile faulty.c with:
  $ gcc faulty.c -o faulty


Using the example code:
  You can point the memory back at address \xff\x05\x40\x00\x00\x00\x00\x00 (the
  subroutine containing the code that spawns bash) with:
  $ ./faulty -a $(perl -e 'print "A"x24;print "\x00\xff\x05\x40\x00\x00\x00\x00\x00"')
  The address may be a little different under your distro, check gdb if you really
  want to try it out.  The code above /should/ drop you at a bash prompt.
  If the code is set to a mode where all are able to execute as another user, it will
  attempt to spawn a root shell.


Useage:
  ./segfault_4me -[tm] [template manpage] /path/to/executable buffersize

  Examples:
  $ echo "Marshall" | ./segfault_4me -t template ./faulty 64
  $ ./segfault_4me -m mount /usr/sbin/mount 2048

Recommendations:
  DO NOT RUN THIS CODE AS ROOT!
  If you try setting faulty.c's output to suid(0) then PLEASE do it in a virtual machine
  or atleast a machine that you don't care about.
  Other than that, just play around and have fun!

Notes:
  As for now, this code is mostly still in an experimental state, and may not work
  correctly.
