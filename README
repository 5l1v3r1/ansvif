# ansvif
A Not So Very Intelligent Fuzzer.

Compliation:
 Linux:
  You can compile the code with:
  $ make && make test
  OpenBSD:
  $ make && make test
  Windows:
  Precompiled binaries are left in a zip file in ./bin.
  Use cygwin, install g++ and gcc.
  (In cygwin)
  $ mv include/gzstream/gzstream.h-win include/gzstream.h
  $ g++ src/common.cpp src/win/bin2hex.cpp src/match_seg.cpp src/win/main.cpp src/win/help.cpp src/win/popen2.cpp src/win/man_read.cpp src/win/sys_string.cpp -lstdc++ -std=gnu++11 -O3 -o bin/ansvif_win/ansvif.exe -lpthread
  $ gcc src/win/printf.c -o bin/printf
  $ cp /bin/cyggcc_s-seh-1.dll /bin/cygstdc++-6.dll /bin/cygwin1.dll bin/
  Make sure cyggcc_s-seh-1.dll, cygstdc++-6.dll and cygwin1.dll are in the same directory as ansvif.exe.

  If you would like to try out the example code, you can compile faulty.c with:
  $ gcc faulty.c -o faulty


Using the example code:
  You can point the memory back at address \xff\x05\x40\x00\x00\x00\x00\x00 (the
  subroutine containing the code that spawns bash) with:
  $ ./faulty -a $(perl -e 'print "A"x24;print "\x00\xff\x05\x40\x00\x00\x00\x00\x00"')
  The address may be a little different under your distro, check gdb if you really
  want to try it out.  The code above /should/ drop you at a bash prompt.
  If the code is set to a mode where all are able to execute as another user, it will
  attempt to spawn a root shell.


Useage:
  Important note: Windows users will have to run ansvif.exe from Powershell for it to work!

  $ ./find_suid /usr/bin/ /bin/ /sbin/
  $ ./ansvif -[tm] [template/manpage] -c /path/to/executable -b buffersize

  Examples:
   Linux/BSD:
  $ echo "Marshall" ./ansvif -t examples/template -c ./faulty -b 64
  $ ./ansvif -m mount -c /usr/sbin/mount -e examples/template_env -x examples/template_other -f 8 -b 2048
  $ ./ansvif -t examples/blank -F tmp/tmphtml -x examples/htmltags -c /usr/bin/iceweasel -b 128 -A "file:///home/username/src/ansvif/tmp/tmphtml"  -f 2 -n -R "sleep 3 && killall iceweasel" -S ">"
  Windows:
  PS C:\ansvif\bin\ansvif_win> .\ansvif -t ..\..\examples\space -F ..\..\tmp\tmphtml -x ..\..\examples\htmltags -c 'C:\Program Files (x86)\Google\Chrome\Application\chrome.exe' -b 128 -A "file:///C:\\Users\marsh\OneDrive\Documents\Code\ansvif\tmp\tmphtml" -f 2 -n -S ">" -R "sleep 2 ; Stop-Process -Name chrome"


Options:
  -t This file should hold line by line command arguments as shown in the example file.
  -e This file should hold line by line environment variables as shown in the example
     file.  You can usually get these by doing something like:
     $ strings /bin/mount | perl -ne 'print if /[A-Z]=$/' > mount_envs
  -c Specifies the command path.
  -p Specifies the manpage location (as an integer, usually 1 or 8)
  -m Specifies the commands manpage.
  -D Dumps whats found in the manpage.
  -f Number of threads to use.  Default is 2.
  -b Specifies the buffer size to fuzz with.  256-2048 Is usually sufficient.
  -r Uses only random garbage data.  (note: this is buggy)
  -o Writes output to log file.
  -z Randomize the buffer size from 1 to what is specified by -b.
  -x Other junk to put in.  Usernames and such can go here.
  -S Seperator between options.
  -v Verbose.
  -T Timeout for threads.
  -L Unpriviledged user to run as if root.
  -A Always put whats after this in the command to run.
  -F File to feed into the program that -x along with normal fuzzing data will be put in.
  -n Never use random data in the fuzz.
  -R Run this command after each fuzz.
  -C C++ formatted regex of crash codes to detect. For example: "(139|136)"
  -d Debug data.
  -h Shows the help page.

Recommendations:
  DO NOT RUN THIS CODE IN A PRODUCTION ENVIRONMENT!
  If you try setting faulty.c's output to suid(0) then PLEASE do it in a virtual machine
  or atleast a machine that you don't care about.
  Other than that, just play around and have fun!


Notes:
  Windows users must have ansvif running from Powershell.  Windows code is in an experimental state.
  Linux code should be relatively stable.
